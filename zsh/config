#! /bin/zsh

# Updated to include changes based on what I expect and what I cribbed from
# Chris Neukirchen.

autoload colors zsh/terminfo
[[ "${terminfo[colors]}" -ge 8 ]] && colors

if [[ -n ${SSH_CONNECTION} ]]; then
  export PS1='%m:%3~$(git_info_for_prompt)%# '
else
  export PS1='%3~$(git_info_for_prompt)%# '
fi

export ZMESSDIR=~/mess

# export EDITOR='mate -w'
export EDITOR='mvim'

export PATH=${HOME}/bin:/usr/local/bin:/usr/local/sbin:/opt/local/bin:/opt/local/sbin:/usr/local/git/bin:${PATH}
export MANPATH=/usr/local/man:/opt/local/man:/usr/local/git/man:${MANPATH}

fpath=(~/.zsh/functions ~/.zsh/git/functions ${fpath})
autoload -U ~/.zsh/functions/*(:t)

HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=1000

setopt BASH_AUTO_LIST
setopt AUTO_MENU
setopt NO_ALWAYS_LAST_PROMPT
setopt NO_LIST_BEEP

setopt NO_BG_NICE # don't nice background tasks
setopt NO_HUP

setopt LOCAL_OPTIONS # allow functions to have local options
setopt LOCAL_TRAPS # allow functions to have local traps
setopt HIST_VERIFY
setopt PROMPT_SUBST
setopt CORRECT
setopt COMPLETE_IN_WORD
# setopt IGNORE_EOF # disables '^D' to logout

setopt APPEND_HISTORY # adds history
setopt INC_APPEND_HISTORY SHARE_HISTORY  # adds history incrementally and share it across sessions
setopt HIST_IGNORE_ALL_DUPS  # don't record dupes in history
setopt HIST_REDUCE_BLANKS
setopt SHARE_HISTORY # share history between sessions ???
setopt EXTENDED_HISTORY # add timestamps to history
setopt extended_glob

zle -N newtab
zle -N rationalise_dot

bindkey '^[^[[D' backward-word
bindkey '^[^[[C' forward-word
bindkey '^[[5D' beginning-of-line
bindkey '^[[5C' end-of-line
bindkey '^[[3~' delete-char
bindkey '^[^N' newtab
bindkey '^?' backward-delete-char 

bindkey . rationalise_dot

# Z line editor, zsh’s version of readline has a very good Emacs keybinding
# support which we’ll enable and configure it to regard / as a word seperator
# too (highly useful for editing paths):
WORDCHARS=${WORDCHARS//[&=\/;!#%\{]}
bindkey -e

# === The old prompt code, before "wunjo".
# # How it looks, for example:
# #   [1] 2#276<p5>lilith:.../rack/lib/rack$
# # This means, the last command exited with status 1, it is a second-level
# # subshell, line 276 of history (for !), running on ttyp5 on my trusty iBook
# # lilith, and I'm a normal user ($) in the rack/lib/rack directory on my disk
# # (I know where that is).
# #
# # I don’t use a right-hand-side prompt at the moment because I think it’s
# # confusing, especially if your terminal isn’t very wide.
# 
# # Terminal title, using a precmd. Host and path are enough for my purposes.
# precmd()
# {
# # print -Pn "\e]0;%n@%m: %d\a"
# 
#   local TERMWIDTH
#   (( TERMWIDTH = ${COLUMNS} - 1 ))
# 
#   # Truncate the path if it's too long.
#   PR_FILLBAR=""
#   PR_PWDLEN=""
# 
#   local promptsize=${#${(%):---(%n@%m:%l)---()--}}
#   local pwdsize=${#${(%):-%~}}
# 
#   if [[ "$promptsize + $pwdsize" -gt $TERMWIDTH ]]; then
#     ((PR_PWDLEN=$TERMWIDTH - $promptsize))
#   else
#     PR_FILLBAR="\${(l.(($TERMWIDTH - ($promptsize + $pwdsize)))..${PR_HBAR}.)}"
#   fi
# }
# 
# preexec()
# {
#   if [[ "$TERM" == "screen" ]]; then
#     local CMD=${1[(wr)^(*=*|sudo|-*)]}
#     echo -n "\ek$CMD\e\\"
#   fi
# }
# 
# setprompt()
# {
#   # Need this so the prompt will work.
#   setopt prompt_subst
# 
#   PR_TITLEBAR=''
#   PR_STITLE=''
# 
#   # Decide if we need to set titlebar text.
#   # Decide whether to set a screen title
#   case $TERM in
#     xterm*|ansi)    PR_TITLEBAR=$'%{\e]0;%(!.-=*[ROOT]*=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\a%}'
#                     ;;
#     screen)         PR_TITLEBAR=$'%{\e_screen \005 (\005t) | %(!.-=[ROOT]=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\e\\%}'
#                     PR_STITLE=$'%{\ekzsh\e\\%}'
#                     ;;
#   esac
# 
#   if [[ -n ${SSH_CONNECTION} ]]; then
#     export PS1='${PR_STITLE}${(e)PR_TITLEBAR}%(?..${fg_bold[red]}(%?%) )${reset_color}\
# ${fg[blue]}(${fg[green]}%(!.%SROOT%s.%n)${fg[green]}@%m:%l${fg[blue]}) \
# ${fg[blue]}[${fg[magenta]}%(4~,.../,)%3~${fg[blue]}]\
# $(git_info_for_prompt "${fg[green]}|%s")
# %(2L.${fg[blue]}<${fg[green]}%L${fg[blue]}>.)\
# ${fg[cyan]}%h${fg[blue]}%(!.#.$) ${reset_color}'
#   else
#     export PS1='$PR_STITLE${(e)PR_TITLEBAR}%(?..${fg_bold[red]}(%?%) )${reset_color}\
# %(!.${fg[blue]}(${fg[green]}%SROOT%s${fg[green]}@%m${fg[blue]}) .)\
# ${fg[blue]}[${fg[magenta]}%(4~,.../,)%3~${fg[blue]}]\
# $(git_info_for_prompt "${fg[green]}|%s")
# %(2L.${fg[blue]}<${fg[green]}%L${fg[blue]}>.)\
# ${fg[cyan]}%h${fg[blue]}%(!.#.$) ${reset_color}'
#   fi
# 
#   PS2="${fg[blue]}($fg_bold[green]%_${fg[blue]})${reset_color} "
# }
# 
# # The prompt, I used a rather bloated prompt with Bash; this is a stripped-down
# # version with everything removed I don’t need. (And the monochrome version.)
# 
# # setprompt

setopt prompt_subst
autoload -U promptinit
promptinit

prompt wunjo
