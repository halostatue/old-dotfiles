#! /bin/zsh

# The names of the zsh plugins we will be supporting.
typeset -ga zsh_plugins

# Run the detection script for plugins. The detection script format is fairly
# simple. It must be one or more of the following lines:
#
#   [command] <COMMAND>
#       The "command" directive tests to see if the provided COMMAND is a
#       program, script, or shell function that exists. The "command" directive
#       is optional; any COMMAND may appear on a line by itself and it is
#       treated as having an implicit "command" directive. This returns true if
#       the output of the Zsh builtin "command -v" returns any value.
#   alternates <COMMAND>+
#       The "alternates" directive is followed by one or more COMMANDs that are
#       tested the same way as noted for the "command" directive. The
#       difference is that only one of these must exist for the result to be
#       true. All of the alternates must be on a single line.
#   do <COMMAND> [parameters]
#       The "do" directive is followed by a COMMAND that will be executed with
#       the provided parameters. The output is discarded and the shell return
#       value ($?) will be used to determine whether this directive passes in
#       the usual shell manner (e.g., $? must be 0 to be true).
#   do-return <VALUE> <COMMAND> [parameters]
#       For the rare case where a COMMAND must be executed where a success
#       value is a non-zero value, a value may be provided with this
#       alternative form of the "do" directive.
#   directory <PATH>+
#   file <PATH>+
#   executable <PATH>+
#       These directives will test to see if one or more paths exist (as a
#       directory, a file, or an executable file) using the result of "test
#       -d", "test -f", or "test -x" on the provided PATH values. Before the
#       test is run, the PATH is eval-echoed (e.g., mypath=$(eval echo
#       "${mypath}") so that environment variables and glob expansions are
#       resolved prior to the test. Only one of the resolved paths must match
#       the condition to be true.
#
#       Note that the directory, file, and executable directives won't work
#       with paths that have spaces in them, even if they are quoted or
#       escaped.
#
for plugin (~/.zsh/plugins/**/detect(.)); do
  # roughly basename(dirname($plugin))
  name=${plugin:h:t}
  found=false

  while builtin read -A line; do
    directive=${line[1]}
    shift line

    local -i expected_return_value=0

    # Deal with the fact that the "command" directive is optional. While we're
    # at it, also make it so that any of the directives by themselves can be
    # treated as "command <directive>", just in case.
    case ${directive} in
      do-return)
        if [[ ${#line} = 0 ]]; then
          line[1]=(${directive} ${line[1]})
          directive="command"
        elif [[ ${#line} -ge 2 ]]; then
          expected_return_value=${line[1]}
          shift line
        fi
        ;;
      alternates|"do"|directory|file|executable)
        if [[ ${#line} = 0 ]]; then
          line[1]=(${directive} ${line[1]})
          directive="command"
        fi
        ;;
      *)
        line[1]=(${directive} ${line[1]})
        directive="command"
        ;;
    esac

    cmd=${line[1]}
    shift line

    case ${directive} in
      do-return|"do")
        cmd=$(eval "echo ${cmd}")
        ${cmd} ${line[*]} > /dev/null 2> /dev/null
        res=${?}
        if [[ ${expected_return_value} = ${res} ]]; then
          found=true
        else
          found=false
        fi
        ;;
      directory|file|executable)
        itemfound=false
        spath=($(eval "echo ${cmd} ${line[@]}"))

        for item (${spath[@]}); do
          case ${directive} in
            directory)
              if [ -d "${item}" ]; then
                itemfound=true
                break
              fi
              ;;
            file)
              if [ -f "${item}" ]; then
                itemfound=true
                break
              fi
              ;;
            executable)
              if [ -x "${item}" ]; then
                itemfound=true
                break
              fi
              ;;
          esac
        done

        found=$itemfound
        ;;
      alternates)
        altfound=false
        for alternate (${cmd} ${line[*]}); do
          alt=$(command -v ${alternate})
          if [ -n "${alt}" ]; then
            altfound=true
            break
          fi
        done

        found=$altfound
        ;;
      "command")
        res=$(command -v ${cmd})

        if [ -n "${res}" ]; then
          found=true
        else
          found=false
        fi
        ;;
    esac

    if not $found; then
      break
    fi
  done < ${plugin}

  if ${found}; then
    zsh_plugins+=(${name})
  fi
done

for plugin (${zsh_plugins}); do
  fpath=(~/.zsh/plugins/${plugin}/functions ${fpath})
  [ -r ~/.zsh/plugins/${plugin}/init ] && source ~/.zsh/plugins/${plugin}/init
  add-paths-before-if ~/.zsh/plugins/${plugin}/bin
done

autoload -U $^fpath/*(N.:t)
