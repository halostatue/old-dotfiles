#! /bin/zsh

typeset __hzsh_plugins_path
__hzsh_plugins_path=$(builtin echo ${1:-$(builtin echo ${0:h})}(:A))
__hzsh_plugins_path=$(builtin echo ${__hzsh_plugins_path%/})

# The names of the zsh plugins we will be supporting. This is global and will
# exist after plug-in initialization is complete.
typeset -ga __hzsh_plugins
__hzsh_plugins=()

# We will support a list of missing plug-ins that can be re-searched if a
# plug-in initialization claims that it can affect plugin setup.
typeset -a __hzsh_known_plugins __hzsh_missing_plugins __hzsh_found_plugins
__hzsh_missing_plugins=()
__hzsh_found_plugins=()
__hzsh_known_plugins=(${__hzsh_plugins_path}/*(/:t))

# We also support ZSH style specifications for enabled or disabled plug-ins.
#
#   zstyle :hzsh:plugins disabled list of disabled plug-ins
#
#   zstyle :hzsh:plugins enabled list of enabled plug-ins
#   zstyle :hzsh:plugins:name enabled yes|no
typeset -a __hzsh_enabled __hzsh_disabled
zstyle -a :hzsh:plugins enabled __hzsh_enabled
zstyle -a :hzsh:plugins disabled __hzsh_disabled

typeset __hzsh_find_plugins=true

function __hzsh_retry_plugin_search()
{
  __hzsh_find_plugins=true
}

function __hzsh_plugin_disabled_by_style()
{
  if [[ ${__hzsh_disabled[(i)${1}]} -le ${#__hzsh_disabled} ]]; then
    true
  else
    local enabled
    zstyle -s :hsh:plugins:${1} enabled enabled

    if [ -n "${enabled}" ]; then
      zstyle -b :hzsh:plugins:${1} enabled enabled
      if [[ ${enabled} == 'yes' ]]; then
        false
      else
        true
      fi
    else
      false
    fi
  fi
}

function __hzsh_plugin_enabled_by_style()
{
  if [[ ${__hzsh_enabled[(i)${1}]} -le ${#__hzsh_enabled} ]]; then
    true
  else
    local enabled
    zstyle -b :hzsh:plugins:${1} enabled enabled
    if [[ ${enabled} == 'yes' ]]; then
      true
    else
      false
    fi
  fi
}

function __hzsh_detect_plugin()
{
  local plugin_path="${1}"
  local plugin_detect_file="${plugin_path}/detect"
  local -A current_plugin

  current_plugin=()

  current_plugin[name]=${plugin_path:t}
  current_plugin[found]=false

  if __hzsh_plugin_disabled_by_style ${current_plugin[name]}; then
    # Add to missing plugins just in case another plug-in enables this plug-in.
    __hzsh_missing_plugins+=${current_plugin[name]}
    return
  elif [ ! -f "${plugin_detect_file}" ]; then
    if __hzsh_plugin_enabled_by_style ${current_plugin[name]}; then
      __hzsh_found_plugins+=${current_plugin[name]}
      return
    else
      # Add to missing plugins just in case another plug-in enables this
      # plug-in.
      __hzsh_missing_plugins+=${current_plugin[name]}
      return
    fi
  fi

  local -a current_plugin_line
  while builtin read -A current_plugin_line; do
    current_plugin[directive]=${current_plugin_line[1]}
    shift current_plugin_line

    current_plugin[rc]=0

    # Deal with the fact that the "command" current_plugin[directive] is
    # optional. While we're at it, also make it so that any of the directives
    # by themselves can be treated as "command <current_plugin[directive]>",
    # just in case.
    case ${current_plugin[directive]} in
      do-return)
        if [[ ${#current_plugin_line} = 0 ]]; then
          current_plugin_line[1]=(${current_plugin[directive]} ${line[1]})
          current_plugin[directive]="command"
        elif [[ ${#current_plugin_line} -ge 2 ]]; then
          current_plugin[rc]=${current_plugin_line[1]}
          shift current_plugin_line
        fi
        ;;
      alternates|"do"|directory|file|executable)
        if [[ ${#current_plugin_line} = 0 ]]; then
          current_plugin_line[1]=(${current_plugin[directive]} ${line[1]})
          current_plugin[directive]="command"
        fi
        ;;
      command)
        :
        ;;
      *)
        current_plugin_line[1]=(${current_plugin[directive]} ${line[1]})
        current_plugin[directive]="command"
        ;;
    esac

    current_plugin[cmd]=${current_plugin_line[1]}
    shift current_plugin_line

    case ${current_plugin[directive]} in
      do-return|do)
        current_plugin[cmd]=$(eval "builtin echo ${current_plugin[cmd]}")
        ${current_plugin[cmd]} ${current_plugin_line[*]} > /dev/null 2> /dev/null
        current_plugin[res]=${?}
        if [[ ${current_plugin[rc]} = ${current_plugin[res]} ]]; then
          current_plugin[found]=true
        else
          current_plugin[found]=false
        fi
        ;;
      directory|file|executable)
        current_plugin[itemfound]=false
        local -a plugins_spath

        plugins_spath=($(eval "builtin echo ${current_plugin[cmd]} ${current_plugin_line[@]}"))

        for item (${plugins_spath[@]}); do
          case ${current_plugin[directive]} in
            directory)
              if [ -d "${item}" ]; then
                current_plugin[itemfound]=true
                break
              fi
              ;;
            file)
              if [ -f "${item}" ]; then
                current_plugin[itemfound]=true
                break
              fi
              ;;
            executable)
              if [ -x "${item}" ]; then
                current_plugin[itemfound]=true
                break
              fi
              ;;
          esac
        done

        current_plugin[found]=${current_plugin[itemfound]}
        ;;
      alternates)
        local altfound=false
        for alternate (${current_plugin[cmd]} ${current_plugin_line[*]}); do
          alt=$(command -v ${alternate})
          if [ -n "${alt}" ]; then
            altfound=true
            break
          fi
        done

        current_plugin[found]=${altfound}
        ;;
      command)
        current_plugin[res]=$(command -v ${current_plugin[cmd]})

        if [ -n "${current_plugin[res]}" ]; then
          current_plugin[found]=true
        else
          current_plugin[found]=false
        fi
        ;;
    esac

    if not ${current_plugin[found]}; then
      break
    fi
  done < ${plugin_detect_file}

  if ${current_plugin[found]}; then
    __hzsh_found_plugins+=${current_plugin[name]}
  else
    __hzsh_missing_plugins+=${current_plugin[name]}
  fi

  ${current_plugin[found]}
}

function __hzsh_init_plugin()
{
  __hzsh_plugins+=${1}
  local current_plugin_path="${__hzsh_plugins_path}/${1}"
  local current_plugin_init
  local current_path=${PATH}

  if [ -d ${current_plugin_path}/init ]; then
    declare -a current_plugin_inits
    current_plugin_inits=(${current_plugin_path}/init/*[^~](.N))
    if [ -n "${current_plugin_inits}" ]; then
      for current_plugin_init (${current_plugin_inits}); do
        case ${current_plugin_init} in
          *DISABLED)
            ;;
          *)
            source ${current_plugin_init}
            ;;
        esac
      done
    fi
  elif [ -r ${current_plugin_path}/init ]; then
    source ${current_plugin_path}/init
  fi

  if [ -d ${current_plugin_path}/functions ]; then
    fpath=(${current_plugin_path}/functions ${fpath})
  elif [ -f ${current_plugin_path}/functions ]; then
    source ${current_plugin_path}/functions
  fi

  add-paths-before-if ${current_plugin_path}/bin

  [[ ${PATH} == ${current_path} ]] || __hzsh_retry_plugin_search
}

function __hzsh_find_plugins()
{
  local plugin_name

  while ${__hzsh_find_plugins}; do
    for plugin_name in ${(@)__hzsh_known_plugins}; do
      __hzsh_detect_plugin "${__hzsh_plugins_path}/${plugin_name}"
    done

    __hzsh_known_plugins=(${__hzsh_missing_plugins})
    __hzsh_find_plugins=false

    for plugin_name in ${(@)__hzsh_found_plugins}; do
      __hzsh_init_plugin "${plugin_name}"
    done

    __hzsh_missing_plugins=()
    __hzsh_found_plugins=()
  done
}

__hzsh_find_plugins

unset \
  __hzsh_plugins_path \
  __hzsh_missing_plugins \
  __hzsh_found_plugins \
  __hzsh_known_plugins \
  __hzsh_find_plugins \
  __hzsh_enabled \
  __hzsh_disabled

unfunction \
  __hzsh_retry_plugin_search \
  __hzsh_detect_plugin \
  __hzsh_plugin_disabled_by_style \
  __hzsh_plugin_enabled_by_style \
  __hzsh_init_plugin \
  __hzsh_find_plugins

autoload -U $^fpath/*(N.:t)
