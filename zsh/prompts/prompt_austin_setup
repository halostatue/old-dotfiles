#autoload -U
# austin prompt theme

autoload -U zgitinit && zgitinit
zgit_start_hooks

function prompt_austin_help ()
{
  cat <<'EOF'

prompt austin [[no]right] [[no]verbose]

EOF
}

function prompt_austin_init()
{
  declare -Ag __PAC
  __PAC=(
    default           "%{${fg[default]}%}"
    date              "%{${fg[cyan]}%}"
    time              "%{${fg[blue]}%}"
    host              "%{${fg[green]}%}"
    user              "%{${fg[cyan]}%}"
    punc              "%{${fg[yellow]}%}"
    line              "%{${fg[magenta]}%}"
    hist              "%{${fg[green]}%}"
    path              "%{${fg[cyan]}%}"
    shortpath         "%{${fg[default]}%}"
    rc                "%{${fg[red]}%}"
    scm_branch        "%{${fg[cyan]}%}"
    scm_commitid      "%{${fg[yellow]}%}"
    scm_status_dirty  "%{${fg[red]}%}"
    scm_status_staged "%{${fg[green]}%}"
    \#                "%{%(!.${fg[red]}.${fg[yellow]})%}"
    reset             "%{${fg[default]}%}"
  )

  declare -Ag __PAV
  __PAV=(
    bzr             "bzr"
    cdv             "cdv"
    cvs             "cvs"
    darcs           "darcs"
    git             "±"
    git-p4          "±p₄"
    git-svn         "±svn"
    hg              "☿"
    hg-git          "☿±"
    hg-hgsubversion "☿svn"
    hg-hgsvn        "☿svn"
    mtn             "mtn"
    p4              "p₄"
    svk             "svk"
    svn             "svn"
    tla             "tla"
  )

  declare -Ag __PAF
  __PAF=(
    date              "${__PAC[date]}%D{%Y-%m-%d}${__PAC[reset]}"
    time              "${__PAC[time]}%D{%T}${__PAC[reset]}"
    host              "${__PAC[host]}%m${__PAC[reset]}"
    user              "${__PAC[user]}%n${__PAC[reset]}"
    punc              ""
    line              "${__PAC[line]}%l${__PAC[reset]}"
    hist              "${__PAC[hist]}%h${__PAC[reset]} "
    path              "${__PAC[path]}%(2~.%~.%/)${__PAC[reset]}"
    shortpath         "${__PAC[shortpath]}%1~${__PAC[reset]}"
    rc                "%(?.. ${__PAC[rc]}(%?%)${__PAC[reset]})"
    scm_branch        ""
    scm_commitid      ""
    scm_status_dirty  ""
    scm_status_staged ""
    \#                "${__PAC[#]}%(!.☢.‣)${__PAC[reset]}"
  )


  zstyle ':vcs_info:*:prompt:*' check-for-changes true
  zstyle ':vcs_info:*:prompt:*' unstagedstr '‽'
  zstyle ':vcs_info:*:prompt:*' stagedstr '✓'
}

function __git_revstring()
{
  git describe --tags --always ${1} 2>/dev/null ||
    git rev-parse --short ${1} 2>/dev/null
}

function prompt_austin_setup()
{
  prompt_austin_init

  local -A options

  options[right]=false

  if [[ ${TERM} == screen* ]] && [ -n "${STY}" ]; then
    options[verbose]=false
  else
    options[verbose]=true
  fi

  for arg in "$@"; do
    case ${arg} in
      no*)  options[${arg/no/}]=false ;;
      no_*) options[${arg/no_/}]=false ;;
      *)    options[${arg}]=true ;;
    esac
  done

  PROMPT=

  if ${options[verbose]}; then
    PROMPT+="${__PAF[host]} "
  fi
  PROMPT+="${__PAF[path]}"
  PROMPT+="\$(prompt_austin_scm_status)"
  PROMPT+="${__PAF[rc]}"

  PROMPT+="
"
  PROMPT+="${__PAF[hist]} "
  PROMPT+="${__PAF[shortpath]}"
  PROMPT+="\$(prompt_austin_scm_branch)"
  PROMPT+=" ${__PAF[#]} "

  RPROMPT=
  if ${options[right]}; then
    if ${options[verbose]}; then
      RPROMPT+="${__PAF[date]} ${__PAF[time]} "
    fi
    RPROMPT+="${__PAF[user]}"
    RPROMPT+=" ${__PAF[line]}"
  else
    unset RPROMPT
  fi

  export PROMPT RPROMPT
  if is-at-least 4.3.9; then
    add-zsh-hook precmd prompt_austin_precmd
    # add-zsh-hook preexec prompt_austin_preexec
  else
    # preexec_functions+=(prompt_austin_preexec)
    precmd_functions+=(prompt_austin_precmd)
  fi
}

function prompt_austin_preexec()
{
  if [[ "${TERM}" == "screen" ]]; then
    local CMD=${1[(wr)^(*=*|sudo|-*)]}
    echo -n "\ek${CMD}\e\\"
  fi
}

function prompt_austin_precmd()
{
  local ex=$?
  psvar=()

  if [[ ${ex} -ge 128 ]]; then
    sig=${signals[${ex}-127]}
    psvar[1]="sig${(L)sig}"
  else
    psvar[1]="${ex}"
  fi

  local TERMWIDTH
  (( TERMWIDTH = ${COLUMNS} - 1 ))

  # Truncate the path if it's too long.
  PR_FILLBAR=""
  PR_PWDLEN=""

  local promptsize=${#${(%):---(%n@%m:%l)---()--}}
  local pwdsize=${#${(%):-%~}}

  if [[ "${promptsize} + ${pwdsize}" -gt ${TERMWIDTH} ]]; then
    ((PR_PWDLEN=${TERMWIDTH} - ${promptsize}))
  else
    PR_FILLBAR="\${(l.((${TERMWIDTH} - (${promptsize} + ${pwdsize})))..${PR_HBAR}.)}"
  fi
}

function prompt_austin_scm_status()
{
  zgit_isgit || return

  head=$(zgit_head)
  gitcommit=$(__git_revstring ${head})

  local -a commits

  if zgit_rebaseinfo; then
    orig_commit=$(__git_revstring ${zgit_info[rb_head]})
    orig_name=$(git name-rev --name-only ${zgit_info[rb_head]})
    orig="${__PAC[scm_branch]}${orig_name}${__PAC[punc]}(${__PAC[scm_commitid]}${orig_commit}${__PAC[punc]})"
    onto_commit=$(__git_revstring ${zgit_info[rb_onto]})
    onto_name=$(git name-rev --name-only ${zgit_info[rb_onto]})
    onto="${__PAC[scm_branch]}${onto_name}${__PAC[punc]}(${__PAC[scm_commitid]}${onto_commit}${__PAC[punc]})"

    if [ -n "${zgit_info[rb_upstream]}" ] && [ ${zgit_info[rb_upstream]} != ${zgit_info[rb_onto]} ]; then
      upstream_commit=$(__git_revstring ${zgit_info[rb_upstream]})
      upstream_name=$(git name-rev --name-only ${zgit_info[rb_upstream]})
      upstream="${__PAC[scm_branch]}${upstream_name}${__PAC[punc]}(${__PAC[scm_commitid]}${upstream_commit}${__PAC[punc]})"
      commits+="rebasing ${upstream}${__PAC[reset]}..${orig}${__PAC[reset]} onto ${onto}${__PAC[reset]}"
    else
      commits+="rebasing ${onto}${__PAC[reset]}..${orig}${__PAC[reset]}"
    fi

    local -a revs
    revs=($(git rev-list ${zgit_info[rb_onto]}..HEAD))
    if [ $#revs -gt 0 ]; then
      commits+="\n$#revs commits in"
    fi

    if [ -f ${zgit_info[dotest]}/message ]; then
      mess=$(head -n1 ${zgit_info[dotest]}/message)
      commits+="on ${mess}"
    fi
  elif [ -n "${gitcommit}" ]; then
    commits+="on ${__PAC[scm_branch]}${head}${__PAC[punc]}(${__PAC[scm_commitid]}${gitcommit}${__PAC[punc]})${__PAC[reset]}"
    local track_merge=$(zgit_tracking_merge)
    if [ -n "${track_merge}" ]; then
      if git rev-parse --verify -q ${track_merge} >/dev/null; then
        local track_remote=$(zgit_tracking_remote)
        local tracked=$(__git_revstring ${track_merge} 2>/dev/null)

        local -a revs
        revs=($(git rev-list --reverse ${track_merge}..HEAD))
        if [ $#revs -gt 0 ]; then
          local base=$(__git_revstring ${revs[1]}~1)
          local base_name=$(git name-rev --name-only ${base})
          local base_short=$(__git_revstring ${base})
          local word_commits
          if [ $#revs -gt 1 ]; then
            word_commits='commits'
          else
            word_commits='commit'
          fi

          local conj="since"
          if [[ "${base}" == "${tracked}" ]]; then
            conj+=" tracked"
            tracked=
          fi
          commits+="$#revs ${word_commits} ${conj} ${__PAC[scm_branch]}${base_name}${__PAC[punc]}(${__PAC[scm_commitid]}${base_short}${__PAC[punc]})${__PAC[reset]}"
        fi

        if [ -n "${tracked}" ]; then
          local track_name=${track_merge}
          if [[ ${track_remote} == "." ]]; then
            track_name=${track_name##*/}
          fi
          tracked=$(__git_revstring ${tracked})
          commits+="tracking ${__PAC[scm_branch]}${track_name}${__PAC[punc]}"
          if [[ "${tracked}" != "${gitcommit}" ]]; then
            commits[$#commits]+="(${__PAC[scm_commitid]}${tracked}${__PAC[punc]})"
          fi
          commits[$#commits]+="${__PAC[reset]}"
        fi
      fi
    fi
  fi

  gitsvn=$(git rev-parse --verify -q --short git-svn)
  if [ $? -eq 0 ]; then
    gitsvnrev=$(zgit_svnhead ${gitsvn})
    gitsvn=$(__git_revstring ${gitsvn})
    if [ -n "${gitsvnrev}" ]; then
      local svninfo=''
      local -a revs
      svninfo+="${__PAC[default]}svn${__PAC[punc]}:${__PAC[scm_branch]}r${gitsvnrev}"
      revs=($(git rev-list git-svn..HEAD))
      if [ $#revs -gt 0 ]; then
        svninfo+="${__PAC[punc]}@${__PAC[default]}HEAD~$#revs"
        svninfo+="${__PAC[punc]}(${__PAC[scm_commitid]}${gitsvn}${__PAC[punc]})"
      fi
      commits+=${svninfo}
    fi
  fi

  if [ $#commits -gt 0 ]; then
    echo -n " ${(j: :)commits}"
  fi
}

function prompt_austin_scm_branch()
{
  zgit_isgit || return

  echo -n "${__PAC[punc]}:${__PAC[scm_branch]}$(zgit_head)"

  if zgit_inworktree; then
    if ! zgit_isindexclean; then
      echo -n "${__PAC[scm_status_staged]}+"
    fi

    local -a dirty
    if ! zgit_isworktreeclean; then
      dirty+='!'
    fi

    if zgit_hasunmerged; then
      dirty+='*'
    fi

    if zgit_hasuntracked; then
      dirty+='?'
    fi

    if [ $#dirty -gt 0 ]; then
      echo -n "${__PAC[scm_status_dirty]}${(j::)dirty}"
    fi
  fi

  echo ${__PAC[reset]}
}

prompt_austin_setup "$@"
