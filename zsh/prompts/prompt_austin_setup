#autoload -U
# austin prompt theme

autoload -U zgitinit && zgitinit
zgit_start_hooks

function prompt_austin_help ()
{
  cat <<'EOF'

prompt austin [[no]right] [[no]verbose]

EOF
}

function prompt_austin_init()
{
  declare -Ag __prompt_austin_colors
  __prompt_austin_colors[default]="%{${fg[default]}%}"
  __prompt_austin_colors[date]="%{${fg[cyan]}%}"
  __prompt_austin_colors[time]="%{${fg[blue]}%}"
  __prompt_austin_colors[host]="%{${fg[green]}%}"
  __prompt_austin_colors[user]="%{${fg[cyan]}%}"
  __prompt_austin_colors[punc]="%{${fg[yellow]}%}"
  __prompt_austin_colors[line]="%{${fg[magenta]}%}"
  __prompt_austin_colors[hist]="%{${fg[green]}%}"
  __prompt_austin_colors[path]="%{${fg[cyan]}%}"
  __prompt_austin_colors[shortpath]="%{${fg[default]}%}"
  __prompt_austin_colors[rc]="%{${fg[red]}%}"
  __prompt_austin_colors[scm_branch]="%{${fg[cyan]}%}"
  __prompt_austin_colors[scm_commitid]="%{${fg[yellow]}%}"
  __prompt_austin_colors[scm_status_dirty]="%{${fg[red]}%}"
  __prompt_austin_colors[scm_status_staged]="%{${fg[green]}%}"
  __prompt_austin_colors[#]="%{${fg[yellow]}%}"
  __prompt_austin_colors[reset]="%{${fg[default]}%}"
}


function __git_revstring()
{
  git describe --tags --always ${1} 2>/dev/null ||
    git rev-parse --short ${1} 2>/dev/null
}

function prompt_austin_setup()
{
  prompt_austin_init

  local -A options

  options[right]=false

  if [[ ${TERM} == screen* ]] && [ -n "${STY}" ]; then
    options[verbose]=false
  else
    options[verbose]=true
  fi

  for arg in "$@"; do
    case ${arg} in
      no*)  options[${arg/no/}]=false ;;
      no_*) options[${arg/no_/}]=false ;;
      *)    options[${arg}]=true ;;
    esac
  done

  local p_date p_line p_rc

  p_date="${__prompt_austin_colors[date]}%D{%Y-%m-%d} ${__prompt_austin_colors[time]}%D{%T}${__prompt_austin_colors[reset]}"
  p_line="${__prompt_austin_colors[line]}%l${__prompt_austin_colors[reset]}"

  PROMPT=

  if ${options[verbose]}; then
    PROMPT+="${__prompt_austin_colors[host]}%m${__prompt_austin_colors[reset]} "
  fi
  PROMPT+="${__prompt_austin_colors[path]}%(2~.%~.%/)${__prompt_austin_colors[reset]}"
  PROMPT+="\$(prompt_austin_scm_status)"
  PROMPT+="%(?.. ${__prompt_austin_colors[rc]}(%?%)${__prompt_austin_colors[reset]})"

  PROMPT+="
"
  PROMPT+="${__prompt_austin_colors[hist]}%h${__prompt_austin_colors[reset]} "
  PROMPT+="${__prompt_austin_colors[shortpath]}%1~${__prompt_austin_colors[reset]}"
  PROMPT+="\$(prompt_austin_scm_branch)"
  PROMPT+=" ${__prompt_austin_colors[#]}%#${__prompt_austin_colors[reset]} "

  RPROMPT=
  if ${options[right]}; then
    if ${options[verbose]}; then
      RPROMPT+="${p_date} "
    fi
    RPROMPT+="${__prompt_austin_colors[user]}%n${__prompt_austin_colors[reset]}"
    RPROMPT+=" ${p_line}"
  else
    unset RPROMPT
  fi

  export PROMPT RPROMPT
  if is-at-least 4.3.9; then
    add-zsh-hook precmd prompt_austin_precmd
    # add-zsh-hook preexec prompt_austin_preexec
  else
    # preexec_functions+=(prompt_austin_preexec)
    precmd_functions+=(prompt_austin_precmd)
  fi
}

function prompt_austin_preexec()
{
  if [[ "${TERM}" == "screen" ]]; then
    local CMD=${1[(wr)^(*=*|sudo|-*)]}
    echo -n "\ek${CMD}\e\\"
  fi
}

function prompt_austin_precmd()
{
  local ex=$?
  psvar=()

  if [[ ${ex} -ge 128 ]]; then
    sig=${signals[${ex}-127]}
    psvar[1]="sig${(L)sig}"
  else
    psvar[1]="${ex}"
  fi

  local TERMWIDTH
  (( TERMWIDTH = ${COLUMNS} - 1 ))

  # Truncate the path if it's too long.
  PR_FILLBAR=""
  PR_PWDLEN=""

  local promptsize=${#${(%):---(%n@%m:%l)---()--}}
  local pwdsize=${#${(%):-%~}}

  if [[ "${promptsize} + ${pwdsize}" -gt ${TERMWIDTH} ]]; then
    ((PR_PWDLEN=${TERMWIDTH} - ${promptsize}))
  else
    PR_FILLBAR="\${(l.((${TERMWIDTH} - (${promptsize} + ${pwdsize})))..${PR_HBAR}.)}"
  fi
}

function prompt_austin_scm_status()
{
  zgit_isgit || return

  head=$(zgit_head)
  gitcommit=$(__git_revstring ${head})

  local -a commits

  if zgit_rebaseinfo; then
    orig_commit=$(__git_revstring ${zgit_info[rb_head]})
    orig_name=$(git name-rev --name-only ${zgit_info[rb_head]})
    orig="${__prompt_austin_colors[scm_branch]}${orig_name}${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${orig_commit}${__prompt_austin_colors[punc]})"
    onto_commit=$(__git_revstring ${zgit_info[rb_onto]})
    onto_name=$(git name-rev --name-only ${zgit_info[rb_onto]})
    onto="${__prompt_austin_colors[scm_branch]}${onto_name}${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${onto_commit}${__prompt_austin_colors[punc]})"

    if [ -n "${zgit_info[rb_upstream]}" ] && [ ${zgit_info[rb_upstream]} != ${zgit_info[rb_onto]} ]; then
      upstream_commit=$(__git_revstring ${zgit_info[rb_upstream]})
      upstream_name=$(git name-rev --name-only ${zgit_info[rb_upstream]})
      upstream="${__prompt_austin_colors[scm_branch]}${upstream_name}${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${upstream_commit}${__prompt_austin_colors[punc]})"
      commits+="rebasing ${upstream}${__prompt_austin_colors[reset]}..${orig}${__prompt_austin_colors[reset]} onto ${onto}${__prompt_austin_colors[reset]}"
    else
      commits+="rebasing ${onto}${__prompt_austin_colors[reset]}..${orig}${__prompt_austin_colors[reset]}"
    fi

    local -a revs
    revs=($(git rev-list ${zgit_info[rb_onto]}..HEAD))
    if [ $#revs -gt 0 ]; then
      commits+="\n$#revs commits in"
    fi

    if [ -f ${zgit_info[dotest]}/message ]; then
      mess=$(head -n1 ${zgit_info[dotest]}/message)
      commits+="on ${mess}"
    fi
  elif [ -n "${gitcommit}" ]; then
    commits+="on ${__prompt_austin_colors[scm_branch]}${head}${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${gitcommit}${__prompt_austin_colors[punc]})${__prompt_austin_colors[reset]}"
    local track_merge=$(zgit_tracking_merge)
    if [ -n "${track_merge}" ]; then
      if git rev-parse --verify -q ${track_merge} >/dev/null; then
        local track_remote=$(zgit_tracking_remote)
        local tracked=$(__git_revstring ${track_merge} 2>/dev/null)

        local -a revs
        revs=($(git rev-list --reverse ${track_merge}..HEAD))
        if [ $#revs -gt 0 ]; then
          local base=$(__git_revstring ${revs[1]}~1)
          local base_name=$(git name-rev --name-only ${base})
          local base_short=$(__git_revstring ${base})
          local word_commits
          if [ $#revs -gt 1 ]; then
            word_commits='commits'
          else
            word_commits='commit'
          fi

          local conj="since"
          if [[ "${base}" == "${tracked}" ]]; then
            conj+=" tracked"
            tracked=
          fi
          commits+="$#revs ${word_commits} ${conj} ${__prompt_austin_colors[scm_branch]}${base_name}${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${base_short}${__prompt_austin_colors[punc]})${__prompt_austin_colors[reset]}"
        fi

        if [ -n "${tracked}" ]; then
          local track_name=${track_merge}
          if [[ ${track_remote} == "." ]]; then
            track_name=${track_name##*/}
          fi
          tracked=$(__git_revstring ${tracked})
          commits+="tracking ${__prompt_austin_colors[scm_branch]}${track_name}${__prompt_austin_colors[punc]}"
          if [[ "${tracked}" != "${gitcommit}" ]]; then
            commits[$#commits]+="(${__prompt_austin_colors[scm_commitid]}${tracked}${__prompt_austin_colors[punc]})"
          fi
          commits[$#commits]+="${__prompt_austin_colors[reset]}"
        fi
      fi
    fi
  fi

  gitsvn=$(git rev-parse --verify -q --short git-svn)
  if [ $? -eq 0 ]; then
    gitsvnrev=$(zgit_svnhead ${gitsvn})
    gitsvn=$(__git_revstring ${gitsvn})
    if [ -n "${gitsvnrev}" ]; then
      local svninfo=''
      local -a revs
      svninfo+="${__prompt_austin_colors[default]}svn${__prompt_austin_colors[punc]}:${__prompt_austin_colors[scm_branch]}r${gitsvnrev}"
      revs=($(git rev-list git-svn..HEAD))
      if [ $#revs -gt 0 ]; then
        svninfo+="${__prompt_austin_colors[punc]}@${__prompt_austin_colors[default]}HEAD~$#revs"
        svninfo+="${__prompt_austin_colors[punc]}(${__prompt_austin_colors[scm_commitid]}${gitsvn}${__prompt_austin_colors[punc]})"
      fi
      commits+=${svninfo}
    fi
  fi

  if [ $#commits -gt 0 ]; then
    echo -n " ${(j: :)commits}"
  fi
}

function prompt_austin_scm_branch()
{
  zgit_isgit || return

  echo -n "${__prompt_austin_colors[punc]}:${__prompt_austin_colors[scm_branch]}$(zgit_head)"

  if zgit_inworktree; then
    if ! zgit_isindexclean; then
      echo -n "${__prompt_austin_colors[scm_status_staged]}+"
    fi

    local -a dirty
    if ! zgit_isworktreeclean; then
      dirty+='!'
    fi

    if zgit_hasunmerged; then
      dirty+='*'
    fi

    if zgit_hasuntracked; then
      dirty+='?'
    fi

    if [ $#dirty -gt 0 ]; then
      echo -n "${__prompt_austin_colors[scm_status_dirty]}${(j::)dirty}"
    fi
  fi

  echo ${__prompt_austin_colors[reset]}
}

prompt_austin_setup "$@"
